// EventTarget(в данном случае это класс на который мы вешаем обработчик событий)
// addEventListener регистрирует определённый обработчик события, вызванного на EventTarget
// click это тип события
// event это объект который принимает уведомление, когда событие указанного типа произошло. Event же это любое событие, которое происходит в DOM
// target элемент на котором произошло событие / явлется ссылкой на объект который явлется событием(тут это event) / возвращает элемент, в котором произошло событие / когда событие запускается он явлется элементом который запускает событие
// matches() метод интерфейса Element, он проверяет, будет ли элемент выбран указанным селектором CSS. Element это общий базовый класс от которого наследуются все объекты- элементы(т.е. объекты представляющие элементы)
// я установила обработчик событий для родительского элемента тем самым делегировала событие на родительский элемент, для того чтоб не вешать его на каждую кнопку, соответственно когда будет происходить события они будут всплывать к их родителю.
// делегирование выше позволяет узнать что пользователь кликнул по кнопке. И для того чтоб узнать что была за кнопка и что нужно отобразить при клике по ней?
// data атрибуты используется для распознования элементов в html-коде
// textcontent предоставляет доступ к тексту внутри элемента за вычетом всех тегов С innerHTML вставка происходит «как HTML», со всеми HTML-тегами. С textContent вставка получается «как текст», все символы трактуются буквально.
const calculate = (n1, operator, n2) => {
    let result = '';
    //первое и второе число являются строками и их нужно преобразовать к числу, это можно сделать с помощью parseFloat(преобразует строку в число с плавающей запятой (это означает число с десятичными разрядами))
    if(operator === 'add') {
        result = parseFloat(n1) + parseFloat(n2);
    } else if(operator === 'subtract') {
        result = parseFloat(n1) - parseFloat(n2);
    } else if(operator === 'multiply') {
        result = parseFloat(n1) * parseFloat(n2);
    } else if(operator === 'divide') {
        result = parseFloat(n1) / parseFloat(n2);
    }
    return result;
}
const calculator = document.querySelector('.calculator');
const keys = document.querySelector('.calculator__keys');
const display = document.querySelector('.calculator__display');

keys.addEventListener('click', e => { //прослушивание клавиш и операторов на которые нажали
    if(e.target.matches('button')) { // тут мы создаем объект который реагирует на клик по button
        const key = e.target; // на keys висит опбработчик события клик, далее идет функция которая работает при каждом клике, и переменная key создана чтоб возвращать элемент на котором произошло событие/сохраняем событие в переменную key
        const action = key.dataset.action; //используем data-action атрибут чтоб определить какая клавиша была нажата(он установлен на операторы)
        const keyContent = key.textContent; //Номер нажатой клавиши / число на которое нажато
        const displayNum = display.textContent; //Текущее отображаемое число
        const previousKeyType = calculator.dataset.previousKeyType;
        
        Array.from(key.parentNode.children).forEach(k => k.classList.remove('is-depressed')) //когда нажато число после оператора нужно отоюразить новое число, для этого нужно освободить нажатое состояние. Для этого мы удаляем класс со всех клавиш 
        // Array.from()метод создает новый неглубоко скопированный Array экземпляр из итерируемого или подобного массиву объекта.
        // parentNode возвращает родителя указанного узла в дереве DOM
        // .children возвращает HTML коллекцию, который содержит все дочерние элементы элемента, для которого оно было вызвано.
        // HTML коллекция(представляет собой общую коллекцию (подобный массиву объект, похожий на arguments) элементов (в порядке документа) и предлагает методы и свойства для выбора из списка)
        // .forEach выполняет предоставленную функцию один раз для каждого элемента массива.
        if(!action) { //определяем клик по цифрам
            if(displayNum === '0' || previousKeyType === 'operator' || previousKeyType === 'calculate') { //если калькулятор показывает 0(ноль) или предыдущая нажатая клавиша является оператором или предыдущая операция была расчетом
                display.textContent = keyContent; //то на дисплее мы заменяем ноль или числа числом на которое нажали перед нажатием опретора на число по которому нажали
            } else { //если калькулятор показывает не 0(ноль)
                display.textContent = displayNum + keyContent; //мы добавляем к отображаемому числу нажатую клавишу
            }
            calculator.dataset.previousKeyType = 'number'; //способ сохранения числа 
        } 
        if (
            action === 'add' ||
            action === 'subtract' ||
            action === 'multiply' ||
            action === 'divide' 
            ) {
                //--тут мы добавили это чтоб если мы нажимаем на число-оператор-число и снова оператор, чтоб резульат вычисления появлялся после нажатия оператора во второй раз/это не будет работать поскольку это баг и пофиксили его с помощью && previousKeyType !== 'operator'
                const firstValue = calculator.dataset.firstValue; //первое значение сохранено при нажатии оператора, тут его сохраняем в переменную
                const operator = calculator.dataset.operator; //оператор сохранен при нажатии второго значения, тут оно сохраняется в переменную
                const secondValue = displayNum; //сохраняем второе число введенное в калькулятор, нужно для получения результата, этот резульат введен последним поэтому его не нужно сохранять выше
                if (firstValue && operator && previousKeyType !== 'operator' && previousKeyType !== 'calculate') { // previousKeyType!== 'operator' проверятся для предотвращения подсчета результата если жмешь много раз на оператора/ previousKeyType !== 'calculate' чтобы клавиши оператора не выполняли вычисления, если они нажаты после клавиши равенства
                    //тут мы будем писать расчет для: число-оператор-число-оператор-число итд, нам необходимо получить расчет, то этого наши числа сохранялись в переменные выше и после второго нажатия обновлялись и результат не был получен
                    const calcValue = calculate(firstValue, operator, secondValue); //считаем число-оператор-число и сохраняем в переменную
                    display.textContent = calcValue; //выводим результат на экран
                    calculator.dataset.firstValue = calcValue; //устанавливаем calcValue как firstValue
                } else {
                    calculator.dataset.firstValue = displayNum //если результата нет установляваем displayNum как firstValue
                }
                //--//
                key.classList.add('is-depressed'); //для выделения, что оператор активен
                calculator.dataset.previousKeyType = 'operator'; //после того как мы освободили экран после нажатия на опертор (через Array.from), нужно определить: является ли предыдущая клавиша клавишей оператора.
                calculator.dataset.operator = action; //способ сохранения оператора это -  добавляем его к кастомному атрибуту при нажатии вводе второго числа, нужно для получения результата
            }
        if(action === 'decimal') { //определяем клик по точке
            if(!displayNum.includes('.')) { //проверяем есть ли в строке точка
                display.textContent = displayNum + '.' // когда нажата десятичная точка мы отображаем после нее введенное число для этого мы к введенному числу добавляем точку
            } else if (previousKeyType === 'operator' || previousKeyType === 'calculate') { //Чтоб после ввода числа, нажатия на оператор и затем на нажатие просто точки у нас появлялся 0 и точка 0. Мы каждому действию добавили способ сохранения и если он равен оператору то вывести:
                display.textContent = '0.';
            }
            calculator.dataset.previousKey = 'decimal';  //способ сохранения точки.
        }
        if(action === 'clear') { //определяем клик по очистке
            
            //если нажато AC сборить калькулятор в исходное состояние
            if(key.textContent === 'AC') {//очистка всех сохраненный чисел и операторов
                calculator.dataset.firstValue = '';
                calculator.dataset.modValue = '';
                calculator.dataset.operator = '';
                calculator.dataset.previousKeyType = '';
            } else {
                key.textContent = 'AC';//если нажать на CE должно появится 0 и АС 
            }
            display.textContent = 0;
            calculator.dataset.previousKeyType = 'clear'; //способ сохранения очистки
        }
        if(action !== 'clear') { // заменяем кнопку All Clear(очистить весь экран, отображается по умолчанию) на clear entry(очистить текущую запись)
            const clearButton = calculator.querySelector('[data-action=clear]'); //делаем это проверяя является ли [data-action=clear] если это не так, заменяем AC на CE 
            clearButton.textContent = 'CE';//сама замена
        }
        if(action === 'calculate') { //определяем клик по получению результата
            // чтобы вычислить результат нам нужно получить три значения
            //1. первое число введенное в калькулятор (чтоб его получить нужно сохранить это значение прежде чем оно очиститься. Сделать это можно добавив его к кастомному атрибуту при нажатии оператора)
            //2. оператор (для получения оператора нужно использовать сохранить это значение прежде чем оно очиститься. Сделать это можно добавив его к кастомному атрибуту при нажатии второго числа)
            //3. второе число введенное в калькулятор
            //после расчета нужно заменить отображаемое значение
            let firstValue = calculator.dataset.firstValue; //первое значение сохранено при нажатии оператора, тут его сохраняем в переменную
            const operator = calculator.dataset.operator; //оператор сохранен при нажатии второго значения, тут оно сохраняется в переменную
            let secondValue = displayNum; //сохраняем второе число введенное в калькулятор, нужно для получения результата, этот резульат введен последним поэтому его не нужно сохранять выше
                if(firstValue) { //Когда расчет не требуется, дисплей остается прежним, тоесть при нажатии равенства ранее нажатое число остается на экране
                        if(previousKeyType === 'calculate') { //если нажимать на равенство чтоб расчет происходил дальше, установим уже посчитанное число как первое для подсчета
                            firstValue = displayNum;
                            secondValue = calculator.dataset.modValue; //используем второе значение для расчета(сохранили его ниже)
                        }
                    display.textContent = calculate(firstValue, operator, secondValue) //расчет происходит с помощью calculate функции ниже, тут мы присваиваем ей значения наших чисел и оператора
                }
            calculator.dataset.modValue = secondValue; //сохраняем второе нажатое число для последующего расчета(нажатие на равенство для подсчета)
            calculator.dataset.previousKeyType = 'calculate'; //способ сохранения резульатата
        }
    }
})